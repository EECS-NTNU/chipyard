#!/usr/bin/env python

#******************************************************************************
# Copyright (c) 2016, The Regents of the University of California (Regents).
# All Rights Reserved. See LICENSE for license details.
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# O3-Pipeview Visualization Helper
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#
# Christopher Celio
# 2016 Mar 18
#
# INPUT: a *.out file generated by a Rocket-chip simulator (e.g., BOOM). Each
# output line is annotated with the fetch sequence number to help correlate
# which instruction corresponds to which timestamp printouts:
#
#   (###; O3PipeView:stage: <timestamp-count>)
#
# OUTPUT: a trace compatible with the gem5 o3-pipeview.py visualization script.
#
# Helper script that processes *.out files from a processor (e.g., RISC-V BOOM),
# and re-constructs the log file to match the format expected by the Gem5
# o3-pipeview.py tool.
#
# The theory is that the processor assigns a fetch-sequence number to each
# instruction. As the instruction travels down the pipeline (potentially
# out-of-order), each stage prints to the *.out log the fetch-sequence number
# and the time-stamp. The resulting *.out log will contain an interleaving of
# committed and misspeculated instructions writing time stamps.

# The o3-pipeview.py tool expects to see each instruction's time stamps printed
# contigiously.
#
# NOTE: the o3-pipeview.py tool will print out different stages contigiously
# even if they occurred simultaneously. Example: if decode, rename, and dispatch
# occur on the same cycle, they will be printed as if they appeared on 3
# contigiously, separate cycles. This pipeview-helper tool will SQUASH the later
# stages if they occurred on the same cycle as previous "stages".


# TODO:
#   implement lists as hash tables
#   verify there's no key collision once using hash tables

import optparse
import sys

from collections import deque

def getFSeqNum(line, idx):
    return int(line[0:idx])

def getCycle(line):
    return int(line.split(":")[2])


def generate_pipeview_file(log):
    lines = log.readlines()

    # find fetch sequence number separator, and cache result
    idx = -1
    while True:
        if not lines:
            sys.exit("Error: file contains no pipetrace info.")
        idx = lines[0].find(';')
        if idx != -1:
            break
        else:
            lines.pop(0)

    seq_dict = {}
    for line in lines:
        if ";" not in line:
            continue
        seq = getFSeqNum(line, idx)
        o3_type = line.split(":")[1]
        seq_dict.setdefault(seq, {})[o3_type] = line
    for s in sorted(seq_dict.keys()):
        d = seq_dict[s]
        fetch_id = s
        prev_cycle = 0
        retire_cycle =  getCycle(d["retire"]) if "retire" in d else 0
        for stage in [
            "fetch",
            "decode",
            "rename",
            "a_queue",
            "b_queue",
            "dispatch",
            "issue",
            "complete",
            "retire",
        ]:
            if stage in d:
                line = d[stage]
                cycle = getCycle(line)
                if(cycle==prev_cycle): # skip instructions in same cycle
                    print "O3PipeView:"+stage+": 0"
                elif stage != "retire" and cycle == retire_cycle:
                    print "O3PipeView:"+stage+": 0"
                else:
                    print line[idx+2:]
                    prev_cycle = cycle
            else:
                print "O3PipeView:"+stage+": 0"


def main():
    parser = optparse.OptionParser()
    parser.add_option('-f','--file', dest='infile',
                      help='The input *.out file to parse.', default="")

    (options, args) = parser.parse_args()

    assert options.infile != "", "Empty input file!"

    with open(options.infile, 'r') as log:
        generate_pipeview_file(log)


if __name__ == '__main__':
    main()
